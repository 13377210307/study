设计模式基本概念

1：创建型模式
单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式
2：结构型模式
适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
3：行为型模式
模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式

OOP七大原则
1：开闭原则：对扩展开放，对修改关闭；
2：里氏替换原则：继承必须确保超类所拥有的性质在子类中任然成立
3：依赖倒置原则：要面向接口编程，不要面向实现编程
4：单一职责原则：控制类的粒度大小，将对象解耦，提高内聚性
5：接口隔离原则：要为各个类建立他们需要的专用接口
6：迪米特法则：只与你的直接朋友交谈，不跟陌生人说话
7：合成复用原则：尽量先使用组合或者聚合等关联关系实现，其次再考虑继承。

一：单例模式
1：概念：
保证一个类仅有一个实例，并提供一个访问它的全局访问点
2：


###二：工厂模式
####1：介绍：
在工厂模式中，我们不会给客户端暴露创建逻辑，而是通过一个共同的接口来指向新创建的对象。
####2：目的:
是为了解耦，降低客户端与产品的耦合度。
（一）：简单工厂
1：概念：
根据传入的参数决定需要生产的产品，若需要新增产品则需要改变工厂类中的方法
（二）：工厂方法
1：概念：
工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
2：与简单工厂的对比
相对于简单工厂，他更符合开闭原则。
对于简单工厂，如果需要新增一款产品的话则你需要修改工厂中的方法。而对于工厂方法而言，只需要新增一个产品工厂去创建这个产品即可
（三）：抽象工厂
1：概念
抽象工厂将粒度细分，比如汽车由一个个零件组成，若采用工厂方法时，当这个车零件换了的话，我们就需要再创建一个新的汽车工厂来生产，
但如果采用抽象工厂的话，我们可以将零件抽象出来，然后组合到汽车工厂中。

###三：观察者模式：
####1：概念：
它定义对象间的一对多关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被动更新；
在观察者模式中，发布者发布通知时并不需要知道谁是它的观察者，可以有任意数目的观察者；
uml图
                             Subject   ------------------------------------------------------ Observer
                          addObserver()                                                      updateData()
                          removeObserve()                                                        |
                          notifyAllObserver()                                                    |
                                |                                                                |
                                |                                                                |
                                |                                                                |
                         ConcreteSubject                                                    ConcreteSubject    
                         notifyAllObserver() 
                          
####2：目的：

####3：角色：
观察者：一般为一个抽象类或接口由其他具体观察者去进行继承或实现，他需要主动去获取被观察者的数据（通过构造函数去主动获取）；
被观察者：由对观察者提供数据的成员变量以及观察者集合构成，被观察者还有加入观察者、移除观察者、通知观察者获取数据的功能

####4：案例：
一：
二：
三：
公众号推送文章：
将公众号作为被观察者：里面包含所有关注该公众号的微信用户，有增加微信用户、移除微信用户以及通知所有微信用户的功能；
微信用户作为观察者，里面包含更新数据方法，将微信公众号通过组合的方式放入
四：
微信服务号推送消息：服务号作为主题、业务推送消息，观察者订阅服务号就会收到消息。

####5：优点
让耦合的双方都依赖于抽象，使其中一方的变换都不会影响另外一方

####6：缺点：
1：目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
2：当观察者对象很多时，通知的发布会花费很多时间，若其中一个推送花费很多时间，则会影响之后的推送，可以采用异步影响程序的效率。


四：责任链模式
1：概念：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止
在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
责任链又分为：纯责任链与不纯责任链
纯责任链：在这条链中，其中一个处理过了就不往下处理了
不纯责任链：在这条链中，某个处理类处理依旧往下执行
uml图

                                 client-------------------------------------BaseHandler
                                                                            NextHandler 
                                                                           handleRequest()
                                                                                 |
                                                                                 |
                                                             --------------------------------------------
                                                             |                                          |
                                                             |                                          |
                                                      ConcreteHandler1                             ConcreteHandler2
                                                       handleRequest()                              handleRequest()
                                 
                                 
2：目的：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。


3：总结：
责任链中一个处理者对象，其中只有两个行为，一是处理请求，二是将请求转送给下一个节点，不允许某个处理者对象在处理了请求后又将请求转送给上一个节点的情况。
对于一条责任链来说，一个请求最终只有两种情况，一是被某个处理对象所处理，另一个是所有对象均未对其处理，前一种情况称该责任链为纯的责任链，对于后一种情况称为不纯的责任链，实际应用中，多为不纯的责任链。

3：案例：
请求  -》  请求频率  -》  登陆认证  -》  访问权限  -》 敏感词过滤  -》 ...



###五：桥接模式
####1：概念
将抽象和实现放在两个不同的层次类中，使它们可以独立的变化
类的功能层次结构：父类具有基本功能，在子类中实现新的功能
类的实现层次结构：父类通过声明抽象方法来定义接口，子类通过实现具体方法来实现接口
桥接模式是通过组合的方式建立两个类之间的联系，而不是通过继承。

####3：案例：
如果你有三种型号的毛笔，12种颜料，那么你可以画出36条不同的线，如果对于蜡笔来说的话，他就需要36支笔；因为蜡笔的型号和颜色两个维度都存在蜡笔身上，其中一个改变都会影响;
而对于毛笔来说，只存在一个型号的维度，通过组合的方式实现不同的线。



###六：策略模式
####1：概念
定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
uml图
         |------------------------------------------------------------------------------StrategyB（interface）-----------------ConcreteStrategyD
         |                                                                                      |
      Context-----------------------------------                                                |
                                               |                                          ConcreteStrategyC
   strategy1:Strategy                  StrategyA（interface）-- ConcreteStrategyB     
   strategy2:StrategyB                         |
                                         ConcreteStrategyA    
                                                                                              
####2：目的
在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

####3：角色
环境角色：他包含strategy的引用
抽象策略角色：通常是一个抽象类或接口，它包含具体策略所需的所有方法
具体策略角色：封装了相关的算法或行为

####4：案例
一：
二：
三：
编写鸭子项目，
1：需求如下：
有各种鸭子（野鸭、北京鸭、水鸭等，鸭子有各种行为，比如叫、飞行等；2：显示鸭子的信息
2：采用传统方法解决：抽象鸭子类，具体的鸭子去继承鸭子类，重写鸭子的行为方式。
（1）：出现问题：
   （1）具体的鸭子去继承抽象类的时候都会继承抽象类的方法，继承带来的问题就是：当我们对超类进行改动的时候会影响子类
   （2）虽然可以通过重写父类方法解决，但若需要重写父类全部方法时就显得很麻烦。
3：采用策略模式解决：将父类中的各种行为做成策略接口，比如飞的行为作为一个飞的策略，飞有很会飞，不会飞的具体策略，然后将飞的策略通过组合的方式放入鸭子类中；不同的鸭子通过不同的策略进行组合
四：
植物大战僵尸项目
1：需求：
版本1：所有僵尸必须会攻击、而且会动；区分外观，先开发红头僵尸和绿头僵尸
版本2：所有僵尸需要有移动速度，而且速度需要不一致。
版本3：所有僵尸的攻击方式是不一样的。
版本4：需要再添加两种僵尸：无攻击僵尸和短腿僵尸：无攻击僵尸：可以移动，但是不能攻击；短腿僵尸：可以攻击，但是为远程攻击，移动速度较慢。
版本5：僵尸在开始的时候是没有攻击力的，而且僵尸在碰到障碍物的时候速度会变慢（采用策略模式：将僵尸的攻击方式、移动方式、外观、移动速度抽象为策略，然后通过组合方式进行组合）
五：
设定游戏角色：每个角色对应一个名字、每类角色对应一种样子，每个角色拥有一个攻击、防御技能

####5：优点：
（1）替换了类继承的方式：多用组合，组合可变性高，若用继承的话，父类会影响子类，不好维护和修改代码
（2）减少了if...else的判断

####6：缺点：
（1）容易造成策略类膨胀
（2）客户端需要知道有哪些策略


### 七：状态模式
####1：概念
在软件系统中，经常状态的改变影响着行为的变化。例如房屋状态是可以出租、出售进行卖房、不租意味着不可操作，为了避免操作对象和状态转换紧耦合，状态模式将每种状态对应的行为抽象出来称为单独的对象
这样状态的变化不再依赖于对象内部的行为。
uml图


                  Context----------------------------------------------State
                   state                                             Operation1()
                                                                     Operation2()
                                                                         |
                                                                         |
                                              -------------------------------------------------------
                                              |                                                     |
                                              |                                                     |
                                          ConcreteStateA                                     ConcreteStateB                                  

####2：目的
状态模式主要用来解决对象在多种状态转换时需要对外输出不同的行为的问题，状态和行为是一一对应的，状态之间可以相互转换
当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类

####3：角色
（1）Context类为环境角色，用于维护ConcreteState实例，这个实例定义当前状态
（2）State是抽象状态角色，定义一个接口与Context的一个特点接口相关行为
（3）ConcreteState具体的状态角色，每个子类实现一个与Context的一个状态相关行为

#### 4：案例
一：
app抽奖活动：
（1）假如每参加一次活动要扣除用户50积分，中奖概率10%
（2）奖品数量固定，抽完就不能抽奖
（3）活动有四个状态：可以抽奖、不能抽奖、发放奖品和奖品领完
二：
erp做工单流转得时候需要根据工单得不同状态来设置该工单属于哪个角色得用户可见或者进行一些操作
version1：工单状态都放在这里进行处理，违反单一职责，当需求有改动的时候会违反开闭原则
version2：采用状态模式实现：状态模式的优点就是将各个状态封装成类，然后对这个类进行修改。
三：
买东西订单状态：各个状态可能会有不同的行为动作，所以我们把状态抽象成一个类，在类中编写行为逻辑便于维护。









