设计模式基本概念

1：创建型模式
单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式
2：结构型模式
适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
3：行为型模式
模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式

OOP七大原则
1：开闭原则：对扩展开放，对修改关闭；
2：里氏替换原则：继承必须确保超类所拥有的性质在子类中任然成立
3：依赖倒置原则：要面向接口编程，不要面向实现编程
4：单一职责原则：控制类的粒度大小，将对象解耦，提高内聚性
5：接口隔离原则：要为各个类建立他们需要的专用接口
6：迪米特法则：只与你的直接朋友交谈，不跟陌生人说话
7：合成复用原则：尽量先使用组合或者聚合等关联关系实现，其次再考虑继承。

一：单例模式
1：概念：
保证一个类仅有一个实例，并提供一个访问它的全局访问点
2：


一：工厂模式
1：介绍：
在工厂模式中，我们不会给客户端暴露创建逻辑，而是通过一个共同的接口来指向新创建的对象。
2：目的:
是为了解耦，降低客户端与产品的耦合度。
（一）：简单工厂
（二）：工厂方法
1：概念：
工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
2：与简单工厂的对比
相对于简单工厂，他更符合开闭原则。
对于简单工厂，如果需要新增一款产品的话则你需要修改工厂中的方法。而对于工厂方法而言，只需要新增一个产品工厂去创建这个产品即可
（三）：抽象工厂

###一：观察者模式：
####1：概念：
它定义对象间的一对多关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被动更新；
在观察者模式中，发布者发布通知时并不需要知道谁是它的观察者，可以有任意数目的观察者；
uml图
                             Subject   ------------------------------------------------------ Observer
                          addObserver()                                                      updateData()
                          removeObserve()                                                        |
                          notifyAllObserver()                                                    |
                                |                                                                |
                                |                                                                |
                                |                                                                |
                         ConcreteSubject                                                    ConcreteSubject    
                         notifyAllObserver() 
                          
####2：目的：

####3：角色：
观察者：一般为一个抽象类或接口由其他具体观察者去进行继承或实现，他需要主动去获取被观察者的数据（通过构造函数去主动获取）；
被观察者：由对观察者提供数据的成员变量以及观察者集合构成，被观察者还有加入观察者、移除观察者、通知观察者获取数据的功能

####4：案例：
一：
二：
三：
公众号推送文章：
将公众号作为被观察者：里面包含所有关注该公众号的微信用户，有增加微信用户、移除微信用户以及通知所有微信用户的功能；
微信用户作为观察者，里面包含更新数据方法，将微信公众号通过组合的方式放入

####5：优点
让耦合的双方都依赖于抽象，使其中一方的变换都不会影响另外一方

####6：缺点：
1：目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
2：当观察者对象很多时，通知的发布会花费很多时间，若其中一个推送花费很多时间，则会影响之后的推送，可以采用异步影响程序的效率。


二：责任链模式
1：概念：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止
在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
责任链又分为：纯责任链与不纯责任链
纯责任链：在这条链中，其中一个处理过了就不往下处理了
不纯责任链：在这条链中，某个处理类处理依旧往下执行
uml图

                                 client-------------------------------------BaseHandler
                                                                            NextHandler 
                                                                           handleRequest()
                                                                                 |
                                                                                 |
                                                             --------------------------------------------
                                                             |                                          |
                                                             |                                          |
                                                      ConcreteHandler1                             ConcreteHandler2
                                                       handleRequest()                              handleRequest()
                                 
                                 
2：目的：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。


3：总结：
责任链中一个处理者对象，其中只有两个行为，一是处理请求，二是将请求转送给下一个节点，不允许某个处理者对象在处理了请求后又将请求转送给上一个节点的情况。
对于一条责任链来说，一个请求最终只有两种情况，一是被某个处理对象所处理，另一个是所有对象均未对其处理，前一种情况称该责任链为纯的责任链，对于后一种情况称为不纯的责任链，实际应用中，多为不纯的责任链。

3：案例：
请求  -》  请求频率  -》  登陆认证  -》  访问权限  -》 敏感词过滤  -》 ...



###五：桥接模式
####1：概念
将抽象和实现放在两个不同的层次类中，使它们可以独立的变化
类的功能层次结构：父类具有基本功能，在子类中实现新的功能
类的实现层次结构：父类通过声明抽象方法来定义接口，子类通过实现具体方法来实现接口
桥接模式是通过组合的方式建立两个类之间的联系，而不是通过继承。

####3：案例：
如果你有三种型号的毛笔，12种颜料，那么你可以画出36条不同的线，如果对于蜡笔来说的话，他就需要36支笔；因为蜡笔的型号和颜色两个维度都存在蜡笔身上，其中一个改变都会影响;
而对于毛笔来说，只存在一个型号的维度，通过组合的方式实现不同的线。



###六：策略模式
####1：概念
定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
uml图
         |------------------------------------------------------------------------------StrategyB（interface）-----------------ConcreteStrategyD
         |                                                                                      |
      Context-----------------------------------                                                |
                                               |                                          ConcreteStrategyC
   strategy1:Strategy                  StrategyA（interface）-- ConcreteStrategyB     
   strategy2:StrategyB                         |
                                         ConcreteStrategyA    
                                                                                              
####2：目的
在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

####3：角色
环境角色：他包含strategy的引用
抽象策略角色：通常是一个抽象类或接口，它包含具体策略所需的所有方法
具体策略角色：封装了相关的算法或行为

####4：案例
一：
二：
三：
编写鸭子项目，
1：需求如下：
有各种鸭子（野鸭、北京鸭、水鸭等，鸭子有各种行为，比如叫、飞行等；2：显示鸭子的信息
2：采用传统方法解决：抽象鸭子类，具体的鸭子去继承鸭子类，重写鸭子的行为方式。
（1）：出现问题：
   （1）具体的鸭子去继承抽象类的时候都会继承抽象类的方法，继承带来的问题就是：当我们对超类进行改动的时候会影响子类
   （2）虽然可以通过重写父类方法解决，但若需要重写父类全部方法时就显得很麻烦。
3：采用策略模式解决：将父类中的各种行为做成策略接口，比如飞的行为作为一个飞的策略，飞有很会飞，不会飞的具体策略，然后将飞的策略通过组合的方式放入鸭子类中；不同的鸭子通过不同的策略进行组合
四：
植物大战僵尸项目
1：需求：
版本1：所有僵尸必须会攻击、而且会动；区分外观，先开发红头僵尸和绿头僵尸
版本2：所有僵尸需要有移动速度，而且速度需要不一致。
版本3：所有僵尸的攻击方式是不一样的。
版本4：需要再添加两种僵尸：无攻击僵尸和短腿僵尸：无攻击僵尸：可以移动，但是不能攻击；短腿僵尸：可以攻击，但是为远程攻击，移动速度较慢。
版本5：僵尸在开始的时候是没有攻击力的，而且僵尸在碰到障碍物的时候速度会变慢（采用策略模式：将僵尸的攻击方式、移动方式、外观、移动速度抽象为策略，然后通过组合方式进行组合）

####5：优点：
（1）替换了类继承的方式：多用组合，组合可变性高，若用继承的话，父类会影响子类，不好维护和修改代码
（2）减少了if..else的判断

####6：缺点：
（1）容易造成策略类膨胀
（2）客户端需要知道有哪些策略



