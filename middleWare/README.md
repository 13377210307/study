中间件应用：
中间件包括：缓存、消息队列、RPC框架等

##一：缓存中间件
###一：redis
####1：redis的基本数据类型以及应用场景
1：String类型
（1）概念：
是最基本的数据类型；
（2）命令
（3）应用场景
--（1）：文章阅读量统计：将文章id作为key值，将阅读量作为value值
2：Set类型
（1）概念：
（2）命令
（3）应用场景
--（1）：评论黑名单：将评论黑名单的用户id放入set中，使用isMember方法判断该用户是否为黑名单用户
--（2）：共同好友：将用户a的所有好友放到一个set集合setA，将用户b的所有好友放到一个set集合setB，然后通过sinter setA setB


##二：消息中间件
###一：rabbitMq

###一：面试系列
####1：rabbitMq有什么优缺点
优点：解耦、异步、削峰
相信异步大家用的应该还算多，一般在用户注册一个账号的时候，我们就可以利用mq异步发送短信验证码；
对于解耦我自己用的比较多的就是模块与模块之间的解耦，比如：模块a的某个方法被模块b、c、d依赖，这时加了新需求，模块e也需要a的方法而且模块c不需要模块a的数据了，这样就造成了模块之间的耦合度高；
这时我们就可以使用mq的发布订阅模式、需要数据的模块就进行订阅去消费、否则就取消消费
削峰的话就可以在服务器访问压力大的时候使用了

缺点：系统复杂度变高：消息一致性、消息可靠性、消息重复消费；系统可用性降低：mq宕机问题。

####2：如何解决消息重复消费问题

####3：如何解决消息一致性问题

####4：如何解决消息可靠性问题

####5：mq的组成

####6：mq的工作过程

####7：mq中涉及的设计模式有什么


###二：实战系列
####1：rabbitMq配置死信队列
1：概念：

2：目的：
为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中
3：死信队列的生命周期：
（1）业务消息被投入到业务队列中
（2）消费者消费业务队列中的消息，由于处理过程中发生异常，于是进行nck或reject操作
（3）被nck或reject的消息被放到死信交换机中
（4）死信交换机将消息放到对应的死信队列中
（5）消费者消费死信队列里的消息
4：应用：
对于一些比较重要的业务队列，我们不希望消息消费异常就被丢弃时我们就可以采用死信队列

####2：通过死信队列实现延迟队列
1：概念：延时队列中的元素是希望在指定时间得到和处理的

2：使用场景
（1）订单在十分钟内未支付自动取消
（2）新创建的店铺在十天内没上传商品就自动发消息提醒
（3）账单在一周内未支付则自动结算
（4）用户发起退款，三天之内未处理通知相关运营人员

3：实现：
我们可以通过mq中的ttl属性去实现：ttl是指一个消息或一个队列中的所有消息的最大存活时间，当一条消息被设置了ttl后未在规定时间内被消费就会成为死信。

（1）设置单条消息ttl
AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder();
builder.expiration("6000");
AMQP.BasicProperties properties = builder.build();
channel.basicPublish(exchangeName, routingKey, mandatory, properties, "msg body".getBytes());

（2）设置某个队列中所有消息ttl
Map<String, Object> args = new HashMap<String, Object>();
args.put("x-message-ttl", 6000);
channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);

但这两种方式是有区别的，如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃，而第一种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，
如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。

####3：mq实现削峰
定义队列长度，超过队列长度进行丢弃

####4：mq实现消息可靠性
1：消息丢失：指定一个不存在的交换机，这样会触发消息丢失




