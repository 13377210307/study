一：如何理解进程与线程
1：进程：执行程序的一次执行过程，是系统资源分配的单位
2：线程：一个进程包含多个线程，一个进程至少有一个线程，线程是cpu调度和执行的单位

二：常见方法
1：start：启动一个新线程，在新的线程运行run方法中的代码：start方法只是让线程进入就绪，方法体中的代码并不一定立刻运行（需要等待cpu调度），每个线程对象的satrt方法只能调用一次，调用多次会出现异常
2：run：新线程启动后会调用的方法：如果在构造Thread对象时传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为
3：join：等待线程运行结束
4：setPriority：设置线程优先级（1~10）；较大优先级能提高该线程被cpu调度的几率
5：getState：获取线程状态：6个状态通过enum表示：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED
6：isInterrupted：判断是否被打断：不会清除打断标记
7：isAlive：线程是否存活（是否运行完毕）
8：interrupt：打断线程：若打断线程正在sleep、wait、join会导致被打断线程抛出异常，并清除打断标记，如果线程正在运行，则会设置打断标记。
9：sleep：让当前执行的线程休眠n毫秒，休眠时让出cpu的时间片给其他线程
10：yield：让出当前线程对cpu的使用（主要为了测试和调试）

三：主线程和守护线程
默认情况下，java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。
守护线程的应用：
1：垃圾回收器就是一种守护线程
2：tomcat中的acceptor和poller线程都是守护线程，所以tomcat接收到shutdown命令后，不会等待他们处理完当前请求。

四：线程状态
五种状态：
1：初始状态：即Thead thread = new Thead(); 
2：就绪状态：指该线程已经被创建，等待cpu给它分配时间片就可运行
3：运行状态：指线程获取了CPU时间片，正在运行，当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换
4：阻塞状态
如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】
等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】
与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片
5：终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态
六种状态：
1：NEW 跟五种状态里的初始状态是一个意思
2：RUNNABLE 是当调用了 start() 方法之后的状态，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）
3：BLOCKED 
4：WAITING 
5：TIMED_WAITING 
6：TERMINATED

五：线程安全
1：临界区：
一个程序运行多个线程本身没有问题；
问题出现在多个线程共享资源的时候
多个线程同时对共享资源进行读操作本身也没有问题
问题出现在对对共享资源同时进行读写操作时就有问题了
先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区

2：竞态条件
多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件

3：变量的线程安全分析
1：成员变量和静态变量的线程安全分析
如果没有变量没有在线程间共享，那么变量是安全的
如果变量在线程间共享
如果只有读操作，则线程安全
如果有读写操作，则这段代码是临界区，需要考虑线程安全
2：局部变量线程安全分析
局部变量【局部变量被初始化为基本数据类型】是安全的
局部变量引用的对象未必是安全的
如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的
如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的

六：synchronized
1：synchronized 解决方案
为了避免临界区中的竞态条件发生，由多种手段可以达到
阻塞式解决方案：synchronized ，Lock
非阻塞式解决方案：原子变量
现在讨论使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，
不用担心线程上下文切换
注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码 
同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。

2：synchronized语法
synchronized(对象) // 线程1获得锁， 那么线程2的状态是(blocked)
{
 临界区
}

3：synchronized用法
 class Test{
        public synchronized void test() {
        }
    }
    //等价于
    class Test{
        public void test() {
            synchronized(this) {
            }
        }
    }
//------------------------------------------------------------------------------------------------
    class Test{
        public synchronized static void test() {
        }
    }
   // 等价于
    class Test{
        public static void test() {
            synchronized(Test.class) {
            }
        }
    }
  
  
 六：线程通讯（wait...notify）
 
 1：wait与sleep的区别
 wait会释放锁，但sleep不会释放锁
 
 2：notify
 notify会随机唤醒一个等待的线程；哪个锁对象调用的notify就会随机唤醒持有该锁对象的线程
 使用notify的时候需要加synchronized
 
 2：wait...notify的使用
 synchronized(LOCK) {
   while(条件不成立) {
      LOCK.wait();
   }
   // 干活
 }
 
 // 另一个线程
  synchronized(LOCK) {
     LOCK.notifyAll();
  }
 
 




