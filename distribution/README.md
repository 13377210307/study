一：分布式
1：分布式锁的实现
想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统申请加锁；而这个外部系统，必须实现互斥能力：即两个请求同时进来，
只会给一个进程返回成功，另外一个返回失败（或等待）
我们可以通过redis或zookeeper来实现分布式锁
2：通过redis实现分布式锁
版本一：通过setnx实现加锁操作
（1）通过redis的setnx命令可以实现，它表示set if not exists，如果key不存在，才会设置它的值，否则什么也不做
     setnx lock 1：客户端1，加锁成功
     setnx lock 2：客户端2，加锁失败
     操作完成后，需要及时释放锁，给后来者让出操作共享资源的机会：我们可以通过del命令删除这个key就可以
     del lock：释放锁
（2）存在问题：可能会造成死锁：客户端一直占用这个锁，而其他客户端就永远拿不到这把锁了
    （1）程序处理业务逻辑异常，没及时释放锁
    （2）进程挂了，没机会释放锁
版本二：避免死锁：我们可以通过给锁设置过期时间来避免死锁
（1）给key值设置一个过期时间，让锁在过期时间之后自动释放锁
      setnx lock 1  // 加锁
      expire lock 10  // 10秒之后自动过期
（2）存在问题：设置锁和设置过期时间不是原子性操作，在多线程情况下存在线程不安全问题：只执行了第一条命令，第二条命令来不及执行
   （1）setnx执行成功，执行expire时由于网络问题，执行失败
   （2）setnx执行成功，redis异常宕机，expire没有机会执行
   （3）setnx执行成功，客户端崩溃，expire没有机会执行
版本三： 在redis2.6.12之后，redis扩展了set命令的参数，通过一条命令执行就可以了     
 （1）set lock 1 ex 10 nx
 （2）存在问题：1：存在超过过期时间后自动释放锁；2：锁对象公用并没有独立
    （1）客户端1加锁成功，开始操作共享资源
    （2）客户端1操作共享资源的时间超过了锁的过期时间，锁自动释放
    （3）客户端2开始操作共享资源
    （4）客户端1操作共享资源完成，释放锁
版本四：1：解决操作共享资源时间不准确问题；2：解决线程之间互相释放锁问题
 （1）增加过期时间：但是治标不治本，客户端如果出现其他问题导致时间延长依旧不能解决
 （2）给线程增加一个唯一id，在释放锁的时候通过这个唯一id去判断是否能释放这个锁：
     （1）set lock $uuid ex 20 nx  设置锁
     （2）if redis.get('lock') == $uuid {
            // 释放锁
            redis.del('lock')
         }
 （3）存在问题：在释放锁的时候有get和del两个操作了，你需要保证这两个操作是原子性
版本五：通过lua脚本来保证原子执行：因为redis是单线程的，在执行一个请求的时候，其他请求会进行阻塞，这时候通过lua脚本就可以实现原子执行了
 lua脚本：
 
 // 判断锁是不是自己的，是才进行释放
 if redis.call("GET",KEYS[1]) == ARGV[1]
 then 
   return redis.call("DEL",KEYS[1])
 else
   return 0
 end
 
总结：基于redis实现的分布式锁，流程如下
1：加锁：set $lock_key $unique_id ex $expire_time nx
2：释放共享资源
3：释放锁：lua脚本，先get判断锁是不是自己的，然后通过del进行释放锁






 
