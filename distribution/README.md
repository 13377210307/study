一：分布式
1：分布式锁的实现
想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统申请加锁；而这个外部系统，必须实现互斥能力：即两个请求同时进来，
只会给一个进程返回成功，另外一个返回失败（或等待）
我们可以通过redis或zookeeper来实现分布式锁
2：通过redis实现分布式锁
版本一：通过setnx实现加锁操作
（1）通过redis的setnx命令可以实现，它表示set if not exists，如果key不存在，才会设置它的值，否则什么也不做
     setnx lock 1：客户端1，加锁成功
     setnx lock 2：客户端2，加锁失败
     操作完成后，需要及时释放锁，给后来者让出操作共享资源的机会：我们可以通过del命令删除这个key就可以
     del lock：释放锁
（2）存在问题：可能会造成死锁：客户端一直占用这个锁，而其他客户端就永远拿不到这把锁了
    （1）程序处理业务逻辑异常，没及时释放锁
    （2）进程挂了，没机会释放锁
版本二：避免死锁：我们可以通过给锁设置过期时间来避免死锁
（1）给key值设置一个过期时间，让锁在过期时间之后自动释放锁
      setnx lock 1  // 加锁
      expire lock 10  // 10秒之后自动过期
（2）存在问题：设置锁和设置过期时间不是原子性操作，在多线程情况下存在线程不安全问题：只执行了第一条命令，第二条命令来不及执行
   （1）setnx执行成功，执行expire时由于网络问题，执行失败
   （2）setnx执行成功，redis异常宕机，expire没有机会执行
   （3）setnx执行成功，客户端崩溃，expire没有机会执行
版本三： 在redis2.6.12之后，redis扩展了set命令的参数，通过一条命令执行就可以了     
 （1）set lock 1 ex 10 nx
 （2）存在问题：1：存在超过过期时间后自动释放锁；2：锁对象公用并没有独立
    （1）客户端1加锁成功，开始操作共享资源
    （2）客户端1操作共享资源的时间超过了锁的过期时间，锁自动释放
    （3）客户端2开始操作共享资源
    （4）客户端1操作共享资源完成，释放锁
版本四：
